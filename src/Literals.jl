module Literals

# Basic idea: Numeric literals are integers (if they have no decimal
# dot), rationals (if they do have a decimal dot), or irrationals
# (denoted via special symbols).
#
# Integer and rational literals can be combined via the usual
# arithmetic operations (+, -, *, /, etc.). Integer literals are
# converted to rational literals when necessary, i.e. when they are
# combined with a rational literal, or when they are divided.
#
# When a literal value is combined (via an arithmetic operation) with
# a non-literal value, then it is converted to the type of the other
# operand. As usual, the resulting type also depends on the magnitude
# of the literal.
#
# When a rational literal encounters an integer non-literal, it is
# converted to a floating point number. This is because Julia prefers
# floating point numbers over rational numbers.



# An abstract literal
export Lit
abstract type Lit <: Number end

# A boolean or integer literal value
const ValSigned = Union{Int8, Int16, Int32, Int64, Int128}
const ValUnsigned = Union{UInt8, UInt16, UInt32, UInt64, UInt128}
const ValInteger = Union{Bool, ValSigned, ValUnsigned}
                         
export LitInt
struct LitInt{X} <: Lit
    function LitInt{X}() where {X}
        X::ValInteger
        if X isa Bool
            new{X}()
        elseif X isa Signed
            # Julia requires as to choose a particular type, so we
            # choose to store integers as Int. We could use e.g.
            # Int128 instead, but that would make the code here more
            # complex. This could easily be changed in the future.
            new{Int(X)}()
        else
            new{UInt(X)}()
        end
    end
end
LitInt(X::ValInteger) = LitInt{X}()

# A rational literal value
export LitRat
struct LitRat{N, D} <: Lit
    function LitRat{N, D}() where {N, D}
        N::ValInteger
        D::ValInteger
        new{Int(N), Int(D)}()
    end
end
LitRat(N::ValInteger, D::ValInteger) = LitRat{N, D}()
LitRat(::LitInt{X}) where {X} = LitRat{X, 1}()
LitRat(r::LitRat) = r

# A literal symbol, e.g. an irrational number
export LitSym
struct LitSym{Sym} <: Lit
    LitSym{Sym}() where {Sym} = (Sym::Symbol; new{Sym}())
    # Translate pi to π
    LitSym{:pi}() = LitSym{:π}()
end
LitSym(Sym) = LitSym{Sym}()

# A literal type where we can access the value
const LitVal = Union{LitInt, LitRat}



bigval(::LitInt{X}) where {X} = X isa Bool ? X : BigInt(X)
bigval(::LitRat{N, D}) where {N, D} = BigInt(N) // BigInt(D)
bigval(::LitSym{S}) where {S} = Float64(eval(S))

# Choose a "canonical" type for a value, depending on the value's
# magnitude
litval(x::Bool) = x
function litval(x::Signed)
    typemin(Int) <= x <= typemax(Int) && return Int(x)
    typemin(Int64) <= x <= typemax(Int64) && return Int64(x)
    typemin(Int128) <= x <= typemax(Int128) && return Int128(x)
    BigInt(x)
end
function litval(x::Unsigned)
    x <= typemax(UInt8) && return UInt8(x)
    x <= typemax(UInt16) && return UInt16(x)
    x <= typemax(UInt32) && return UInt32(x)
    x <= typemax(UInt64) && return UInt64(x)
    x <= typemax(UInt128) && return UInt128(x)
    BigInt(x)
end
function litval(x::Rational)
    n, d = numerator(x), denominator(x)
    typemin(Int64) <= n <= typemax(Int64) &&
        typemin(Int64) <= d <= typemax(Int64) && return Rational{Int64}(n, d)
    Rational{BigInt}(x)
end
litval(::LitInt{X}) where {X} = litval(X)
litval(::LitRat{N, D}) where {N, D} = litval(N//D)
litval(x::LitSym) = litfloat(x)

# Convert a literal to a floating-point number without a type hint,
# defaulting to Float64
litfloat(x::Lit) = Float64(x)



# Construct a literal from a non-literal value.
# These function might punt and return a non-literal value instead.
# In the future, these calls would be generated by the parser.
export literal
function literal(x::Integer)
    if x isa Bool
        return LitInt(x)
    elseif x isa Signed
        typemin(Int) <= x <= typemax(Int) && return LitInt(Int(x))
        return litval(x)
    elseif x isa Unsigned
        x <= typemax(UInt) && return LitInt(UInt(x))
        return litval(x)
    else
        return litval(x)
    end
end
function literal(x::Rational)
    n, d = numerator(x), denominator(x)
    typemin(Int) <= n <= typemax(Int) &&
        typemin(Int) <= d <= typemax(Int) && return LitRat(Int(n), Int(d))
    return litval(x)
end
literal(x::Symbol) = LitSym(x)
# This would go away in the future when Irrational is replaced by
# LitSym
literal(::Irrational{S}) where {S} = LitSym(S)
# This would go away in the future when the parser translates numbers
# with decimal dots into a rational representation
function literal(x::Float64)
    r = literal(rationalize(BigInt, x))
    r isa Lit && return r
    x
end
# If the user specifies a particular precision (e.g. Float32), keep it
literal(x::AbstractFloat) = x



# Convert literal to non-literal value
(::Type{N})(x::LitInt) where {N <: Number} = N(litval(x))
(::Type{N})(r::LitRat) where {N <: Number} = N(litval(r))
(::Type{F})(::LitInt{X}) where {F <: AbstractFloat, X} = F(X)
(::Type{F})(::LitRat{N, D}) where {F <: AbstractFloat, N, D} = F(N) / F(D)
(::Type{N})(::LitSym{S}) where {N <: Number, S} = N(eval(S))



# Operations between literal values

# Unary operations
Base. +(x::Lit) = x

Base. -(x::LitVal) = literal(- big(litval(x)))
Base. -(x::Lit) = - litfloat(x)

Base.abs(x::LitVal) = literal(abs(big(litval(x))))
Base.abs(x::Lit) = abs(litfloat(x))

Base.inv(x::LitRat) = literal(inv(big(litval(x))))
Base.inv(x::LitVal) = inv(LitRat(x))
Base.inv(x::Lit) = inv(litfloat(x))

Base.max(x::Lit) = x

Base.min(x::Lit) = x

Base.sign(x::LitVal) = literal(sign(litval(x)))
Base.sign(x::Lit) = sign(litfloat(x))

Base.signbit(x::LitVal) = literal(signbit(litval(x)))
Base.signbit(x::Lit) = signbit(litfloat(x))

# Binary operations
Base. +(x::LitVal, y::LitVal) = literal(big(litval(x)) + big(litval(y)))
Base. +(x::Lit, y::Lit) = litval(x) + litval(y)

Base. -(x::LitVal, y::LitVal) = literal(big(litval(x)) - big(litval(y)))
Base. -(x::Lit, y::Lit) = litval(x) - litval(y)

Base. *(x::LitVal, y::LitVal) = literal(big(litval(x)) * big(litval(y)))
Base. *(x::Lit, y::Lit) = litval(x) * litval(y)

Base. /(x::LitRat, y::LitRat) = literal(big(litval(x)) / big(litval(y)))
Base. /(x::LitVal, y::LitVal) = LitRat(x) / LitRat(y)
Base. /(x::Lit, y::Lit) = litval(x) / litval(y)

Base. \(x::LitRat, y::LitRat) = literal(big(litval(x)) \ big(litval(y)))
Base. \(x::LitVal, y::LitVal) = LitRat(x) \ LitRat(y)
Base. \(x::Lit, y::Lit) = litval(x) \ litval(y)

Base. //(x::LitRat, y::LitRat) = literal(big(litval(x)) // big(litval(y)))
Base. //(x::LitVal, y::LitVal) = LitRat(x) // LitRat(y)
Base. //(x::Lit, y::Lit) = litval(x) // litval(y)

function Base. ^(x::LitInt, y::LitInt{Y}) where {Y}
    if Y >= 0
        literal(big(litval(x)) ^ big(litval(y)))
    else
        # Convert LitInt to LitRat
        LitRat(x) ^ y
    end
end
function Base. ^(x::LitRat, y::LitInt{Y}) where {Y}
    literal(big(litval(x)) ^ big(litval(y)))
end
Base. ^(x::Lit, y::Lit) = litval(x) ^ litval(y)

for op in [:(==), :(!=), :(<), :(>), :(<=), :(>=), :cmp, :copysign, :flipsign]
    stmts = quote
        Base.$op(x::LitVal, y::LitVal) =
            literal($op(big(litval(x)), big(litval(y))))
        Base.$op(x::Lit, y::Lit) = $op(litval(x), litval(y))
    end
    eval(stmts)
end



# # Operations between literal and non-literal values
# 
# # Most operations are handled via type promotion from literal to
# # non-literal values.
# 
# # Base has more complex logic here that we should reproduce
# Base. ^(x, ::LitInt{Y}) where {Y} = Y >= 0 ? x ^ Y : inv(x) ^ literal(-Y)
# Base. ^(x, ::LitInt{0}) = one(x)
# Base. ^(x, ::LitInt{1}) = x
# Base. ^(x, ::LitInt{2}) = x * x
# 
# 
# 
# # # Integer literals convert to any number
# # Base.promote_rule(::Type{LitInt{X}}, ::Type{N <: Number}) = N
# # 
# # # Rational literals convert to floats when meeting integers
# # Base.promote_rule(::Type{LitRat{X, Y}}, ::Type{I <: Integer}) = float(I)
# # Base.promote_rule(::Type{LitRat{X, Y}}, ::Type{R <: Rational}) = R
# # Base.promote_rule(::Type{LitRat{X, Y}}, ::Type{F <: AbstractFloat}) = F
# # 
# # # Literal functions are evaluated
# # Base.promote_rule(::Type{LitFun{Fun, X}}, ::Type{N <: Number}) = N

end
