module Literals

# Basic idea: Numeric literals are integers (if they have no decimal
# dot), rationals (if they do have a decimal dot), or irrationals
# (denoted via special symbols).
#
# Integer and rational literals can be combined via the usual
# arithmetic operations (+, -, *, /, etc.). Integer literals are
# converted to rational literals when necessary, i.e. when they are
# combined with a rational literal, or when they are divided.
#
# When a literal value is combined (via an arithmetic operation) with
# a non-literal value, then it is converted to the type of the other
# operand. As usual, the resulting type also depends on the magnitude
# of the literal.
#
# When a rational literal encounters an integer non-literal, it is
# converted to a floating point number. This is because Julia prefers
# floating point numbers over rational numbers.



# An abstract literal
export Lit
abstract type Lit <: Number end

# TODO: remove 'litval'?
export litval
litval(::L) where {L <: Lit} = @error "litval(::$L) not implemented"

# A boolean or integer literal value
const ValSigned = Union{Int8, Int16, Int32, Int64, Int128}
const ValUnsigned = Union{UInt8, UInt16, UInt32, UInt64, UInt128}
const ValInteger = Union{Bool, ValSigned, ValUnsigned}
                         
export LitInt
struct LitInt{X} <: Lit
    function LitInt{X}() where {X}
        X::ValInteger
        if X isa Bool
            new{X}()
        elseif X isa Signed
            new{Int128(X)}()
        else
            new{UInt128(X)}()
        end
    end
end
LitInt(X::ValInteger) = LitInt{X}()
litval(::LitInt{X}) where {X} = X

# A rational literal value
export LitRat
struct LitRat{N, D} <: Lit
    function LitRat{N, D}() where {N, D}
        N::ValInteger
        D::ValInteger
        new{Int128(N), Int128(D)}()
    end
end
LitRat(N::ValInteger, D::ValInteger) = LitRat{N, D}()
litval(::LitRat{N, D}) where {N, D} = N//D

# A literal function call. Special values (e.g. π) ares stored as
# nullary functions. This is used only for simple functions such as +
# - * / ^ .
export LitFun
struct LitFun{Sym, Args <: Tuple} <: Lit
    LitFun{Sym, Args}() where {Sym, Args<:Tuple} =
        (Sym::Symbol; new{Sym, Args}())
    # Translate pi to π
    LitFun{:pi, Tuple{}}() = LitFun{:π, Tuple{}}()
end
LitFun(Sym) = LitFun{Sym, Tuple{}}()
LitFun(Sym, ::X) where {X <: Lit} = LitFun{Sym, Tuple{X}}()
LitFun(Sym, ::X, ::Y) where {X <: Lit, Y <: Lit} = LitFun{Sym, Tuple{X, Y}}()

# Complex expressions are kept as Julia expressions so that we don't
# generate too many distinct types
export LitExpr
struct LitExpr <: Lit
    fun::Symbol
    args::Vector{Lit}
    LitExpr(fun, args...) = new(fun, Lit[args...])
end



# Construct a literal from a non-literal value
# In the future, these calls would be generated by the parser.
export literal
literal(x::ValInteger) = LitInt(x)
literal(x::Rational{<:ValInteger}) = LitRat(numerator(x), denominator(x))
literal(x::Union{Float16, Float32, Float64}) = literal(rationalize(Int128, x))
literal(sym::Symbol) = LitFun(sym)
literal(::Irrational{S}) where {S} = LitFun(S)
function literal(sym::Symbol, args::Lit...)
    if sym in [:+, :-, :*, :/, ://, :\, :^,
               :(==), :(!=), :(<), :(>), :(<=), :(>=),
               :abs, :cmp, :copysign, :flipsign, :inv, :max, :min, :sign,
               :signbit]
        # Turn simple expressions into LitFun, where we can pattern match
        LitFun(sym, args...)
    else
        # Turn complex expressions into opaque LitExpr
        LitExpr(sym, args...)
    end
end



# Convert literal to non-literal value

# Integer literals default to a type depending on their magnitude, and
# depending on whether they are signed or unsigned
function (::Type{Integer})(::LitInt{X}) where {X}
    if X isa Bool
        return X
    elseif X isa Signed
        typemin(Int) <= X <= typemax(Int) && return Int(X)
        typemin(Int64) <= X <= typemax(Int64) && return Int64(X)
        typemin(Int128) <= X <= typemax(Int128) && return Int128(X)
        BigInt(X)
    else
        X <= typemax(UInt8) && return UInt8(X)
        X <= typemax(UInt16) && return UInt16(X)
        X <= typemax(UInt32) && return UInt32(X)
        X <= typemax(UInt64) && return UInt64(X)
        X <= typemax(UInt128) && return UInt128(X)
        BigInt(X)
    end
end
(::Type{N})(x::LitInt) where {N <: Number} = N(Integer(x))

# Rational literals default to Rational{Int64}
function (::Type{Rational})(::LitRat{N, D}) where {N, D}
    typemin(Int64) <= N <= typemax(Int64) &&
        typemin(Int64) <= D <= typemax(Int64) && return Rational{Int64}(N, D)
    typemin(Int128) <= N <= typemax(Int128) &&
        typemin(Int128) <= D <= typemax(Int128) && return Rational{Int128}(N, D)
    Rational{BigInt}(N, D)
end
(::Type{R})(r::LitRat) where {R <: Rational} = R(Rational(r))

# Floating point literals always default to Float64
(::Type{F})(::LitRat{E, D}) where {F <: AbstractFloat, E, D } = F(E) / F(D)
(::Type{AbstractFloat})(r::LitRat) = Float64(r)

# Constants (currently irrationals) and functions
(::Type{N})(::LitFun{S, Tuple{}}) where {N <: Number, S} = N(eval(S))
(::Type{N})(::LitFun{S, Tuple{X}}) where {N <: Number, S, X <: Lit} =
    eval(S)(N(X()))
(::Type{N})(::LitFun{S, Tuple{X, Y}}) where
        {N <: Number, S, X <: Lit, Y <: Lit} =
    eval(S)(N(X()), N(Y()))

function (::Type{N})(expr::LitExpr) where {N <: Number}
    if isempty(expr.args)
        # Constants (currently only irrationals)
        N(eval(expr.fun))
    else
        # Functions
        eval(expr.fun)(map(N, expr.args)...)
    end
end



# Operations between literal values

# Unary operations
# + x = x
Base. +(x::Lit) = x

Base. -(::LitInt{X}) where {X} = literal(- X)
Base. -(::LitRat{XN, XD}) where {XN, XD} = literal(- XN//XD)
Base. -(x::LitFun) = literal(:-, x)
# -(-x) = x
Base. -(x::LitFun{:-, Tuple{Y}}) where {Y} = Y()
Base. -(x::Lit) = literal(:-, x)

Base.abs(::LitInt{X}) where {X} = literal(abs(X))
Base.abs(::LitRat{XN, XD}) where {XN, XD} = literal(abs(XN//XD))
Base.abs(x::LitFun) = literal(:abs, x)
# abs(abs(x)) = abs(x)
Base.abs(x::LitFun{:abs, Tuple{Y}}) where {Y} = x
# abs(-x) = abs(x)
Base.abs(x::LitFun{:-, Tuple{Y}}) where {Y} = abs(Y())
Base.abs(x::Lit) = literal(:abs, x)

Base.inv(::LitInt{X}) where {X} = inv(literal(X//1))
Base.inv(::LitRat{XN, XD}) where {XN, XD} = literal(inv(XN//XD))
Base.inv(x::LitFun) = literal(:inv, x)
# inv(inv(x)) = x
Base.inv(x::LitFun{:inv, Tuple{Y}}) where {Y} = Y()
Base.inv(x::Lit) = literal(:inv, x)

# max(x) = x
Base.max(x::Lit) = x

# min(x) = x
Base.min(x::Lit) = x

Base.sign(::LitInt{X}) where {X} = literal(sign(X))
Base.sign(::LitRat{XN, XD}) where {XN, XD} = literal(sign(XN//XD))
Base.sign(x::LitFun) = literal(:sign, x)
# sign(sign(x)) = sign(x)
Base.sign(x::LitFun{:sign, Tuple{Y}}) where {Y} = x
Base.sign(x::Lit) = literal(:sign, x)

Base.signbit(::LitInt{X}) where {X} = literal(signbit(X))
Base.signbit(::LitRat{XN, XD}) where {XN, XD} = literal(signbit(XN//XD))
Base.signbit(x::LitFun) = literal(:signbit, x)
# signbit(signbit(x)) = false
Base.signbit(x::LitFun{:signbit, Tuple{Y}}) where {Y} = literal(false)
# signbit(abs(x)) = false
Base.signbit(x::LitFun{:abs, Tuple{Y}}) where {Y} = literal(false)
Base.signbit(x::Lit) = literal(:signbit, x)

# Base.log(x::Lit) = LitExpr(:log, x)
# Base.log(::LitFun{:inv, LitFun{:ℯ}}) = literal(-1)
# Base.log(::LitInt{1}) = literal(0)
# Base.log(::LitFun{:ℯ}) = literal(1)
# Base.log(::LitOp{:^, LitFun{:ℯ}, LitFun{2}}) = literal(2)
# Base.log(::LitOp{:*, LitFun{:ℯ}, LitFun{:ℯ}}) = literal(2)
# Base.log2(x::Lit) = LitFun(:log2, x)
# Base.log2(::LitRat{1, 4}) = literal(-2)
# Base.log2(::LitRat{1, 2}) = literal(-1)
# Base.log2(::LitInt{1}) = literal(0)
# Base.log2(::LitInt{2}) = literal(1)
# Base.log2(::LitInt{4}) = literal(2)
# Base.log10(x::Lit) = LitFun(:log10, x)
# Base.log10(::LitRat{1, 100}) = literal(-2)
# Base.log10(::LitRat{1, 10}) = literal(-1)
# Base.log10(::LitInt{1}) = literal(0)
# Base.log10(::LitInt{10}) = literal(1)
# Base.log10(::LitInt{100}) = literal(2)
# 
# Base.sin(x::Lit) = LitFun(:sin, x)
# Base.sin(::LitInt{0}) = literal(0)
# Base.sin(::LitFun{:π}) = literal(0)
# Base.sin(::LitOp{:*, X, LitFun{:π}}) where {X} = sinpi(X())
# Base.sinpi(x::Lit) = LitFun(:sinpi, x)
# Base.sinpi(::LitInt) = literal(0)

# Binary operations
Base. +(::LitInt{X}, ::LitInt{Y}) where {X, Y} = literal(X + Y)
Base. +(::LitRat{XN, XD}, ::LitRat{YN, YD}) where {XN, XD, YN, YD} =
    literal(XN//XD + YN//YD)
Base. +(x::Lit, y::Lit) = literal(:+, x, y)

Base. -(::LitInt{X}, ::LitInt{Y}) where {X, Y} = literal(X - Y)
Base. -(::LitRat{XN, XD}, ::LitRat{YN, YD}) where {XN, XD, YN, YD} =
    literal(XN//XD - YN//YD)
Base. -(x::Lit, y::Lit) = literal(:-, x, y)

Base. *(::LitInt{X}, ::LitInt{Y}) where {X, Y} = literal(X * Y)
Base. *(::LitRat{XN, XD}, ::LitRat{YN, YD}) where {XN, XD, YN, YD} =
    literal(XN//XD * YN//YD)
Base. *(x::Lit, y::Lit) = literal(:*, x, y)

Base. /(::LitInt{X}, ::LitInt{Y}) where {X, Y} = literal(X//Y)
Base. /(::LitRat{XN, XD}, ::LitRat{YN, YD}) where {XN, XD, YN, YD} =
    literal(XN//XD / YN//YD)
Base. /(x::Lit, y::Lit) = literal(:/, x, y)

Base. //(::LitInt{X}, ::LitInt{Y}) where {X, Y} = literal(X//Y)
Base. //(::LitRat{XN, XD}, ::LitRat{YN, YD}) where {XN, XD, YN, YD} =
    literal((XN//XD) // (YN//YD))
Base. //(x::Lit, y::Lit) = literal(://, x, y)

Base. \(::LitInt{X}, ::LitInt{Y}) where {X, Y} = literal(X\Y)
Base. \(::LitRat{XN, XD}, ::LitRat{YN, YD}) where {XN, XD, YN, YD} =
    literal(XN//XD \ YN//YD)
Base. \(x::Lit, y::Lit) = literal(:\, x, y)

# Base. ^(::LitInt{X}, ::LitInt{Y}) where {X, Y} =
#     Y >= 0 ? literal(X ^ Y) : literal(X//1) ^ literal(-Y)
# Base. ^(::LitInt{X}, ::LitInt{0}) where {X, Y} = literal(1)
# Base. ^(::LitInt{X}, ::LitInt{1}) where {X, Y} = literal(X)
# # Base. ^(::LitInt{X}, ::LitInt{2}) where {X, Y} = literal(X) * literal(X)
# Base. ^(::LitInt{X}, ::LitInt{-1}) where {X, Y} = literal(1//X)
# Base. ^(::LitRat{XN, XD}, ::LitInt{Y}) where {XN, XD, Y} = literal(XN//XD ^ Y)
# Base. ^(::LitRat{XN, XD}, ::LitInt{0}) where {XN, XD, Y} = literal(1)
# Base. ^(::LitRat{XN, XD}, ::LitInt{1}) where {XN, XD, Y} = literal(XN//XD)
# # Base. ^(::LitRat{XN, XD}, ::LitInt{2}) where {XN, XD, Y} =
# #     literal(XN//XD) * literal(XN//XD)
# Base. ^(::LitRat{XN, XD}, ::LitInt{-1}) where {XN, XD, Y} = inv(literal(XN//XD))
# Base. ^(x::Lit, y::Lit) = literal(:^, x, y)
# Base. ^(::LitSym{:ℯ}, y::Lit) = literal(:exp, y)
# Base. ^(::LitInt{2}, y::Lit) = literal(:exp2, y)
# Base. ^(::LitInt{10}, y::Lit) = literal(:exp10, y)
# Base. ^(x::Lit, ::LitInt{0}) = literal(1)
# Base. ^(x::Lit, ::LitInt{1}) = x
# Base. ^(x::Lit, ::LitInt{-1})= inv(x)

for op in [:(==), :(!=), :(<), :(>), :(<=), :(>=)]
    result_if_equal = op in [:(==), :(<=), :(>=)]
    stmts = quote
        Base.$op(::LitInt{X}, ::LitInt{Y}) where {X, Y} = literal($op(X, Y))
        Base.$op(::LitRat{XN, XD}, ::LitRat{YN, YD}) where {XN, XD, YN, YD} =
            literal($op(XN//YD, YN//YD))
        Base.$op(x::Lit, y::Lit) =
            x === y ? literal($result_if_equal) : literal(Symbol($op), x, y)
    end
    eval(stmts)
end

Base.cmp(::LitInt{X}, ::LitInt{Y}) where {X, Y} = literal(cmp(X, Y))
Base.cmp(::LitRat{XN, XD}, ::LitRat{YN, YD}) where {XN, XD, YN, YD} =
    literal(cmp(XN//XD, YN//YD))
Base.cmp(x::Lit, y::Lit) = x === y ? literal(0) : literal(:cmp, x, y)

Base.copysign(::LitInt{X}, ::LitInt{Y}) where {X, Y} = literal(copysign(X, Y))
Base.copysign(::LitRat{XN, XD}, ::LitRat{YN, YD}) where {XN, XD, YN, YD} =
    literal(copysign(XN//XD, YN//YD))
Base.copysign(x::Lit, y::Lit) = literal(:copysign, x, y)

Base.flipsign(::LitInt{X}, ::LitInt{Y}) where {X, Y} = literal(flipsign(X, Y))
Base.flipsign(::LitRat{XN, XD}, ::LitRat{YN, YD}) where {XN, XD, YN, YD} =
    literal(flipsign(XN//XD, YN//YD))
Base.flipsign(x::Lit, y::Lit) = literal(:flipsign, x, y)



# # Operations between literal and non-literal values
# 
# # Most operations are handled via type promotion from literal to
# # non-literal values.
# 
# # Base has more complex logic here that we should reproduce
# Base. ^(x, ::LitInt{Y}) where {Y} = Y >= 0 ? x ^ Y : inv(x) ^ literal(-Y)
# Base. ^(x, ::LitInt{0}) = one(x)
# Base. ^(x, ::LitInt{1}) = x
# Base. ^(x, ::LitInt{2}) = x * x
# 
# 
# 
# # # Integer literals convert to any number
# # Base.promote_rule(::Type{LitInt{X}}, ::Type{N <: Number}) = N
# # 
# # # Rational literals convert to floats when meeting integers
# # Base.promote_rule(::Type{LitRat{X, Y}}, ::Type{I <: Integer}) = float(I)
# # Base.promote_rule(::Type{LitRat{X, Y}}, ::Type{R <: Rational}) = R
# # Base.promote_rule(::Type{LitRat{X, Y}}, ::Type{F <: AbstractFloat}) = F
# # 
# # # Literal functions are evaluated
# # Base.promote_rule(::Type{LitFun{Fun, X}}, ::Type{N <: Number}) = N

end
